import { exec } from 'child_process';
import { promisify } from 'util';
import axios from 'axios';

const execAsync = promisify(exec);

interface VulnerabilityScanParams {
  scanType: 'container' | 'dependency' | 'network' | 'web';
  target: string;
  severity?: 'critical' | 'high' | 'medium' | 'low' | 'all';
}

interface ScanResult {
  type: string;
  target: string;
  collectedAt: string;
  vulnerabilities: Vulnerability[];
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    total: number;
  };
  scanDuration: number;
}

interface Vulnerability {
  id: string;
  severity: string;
  title: string;
  description?: string;
  package?: string;
  version?: string;
  fixedVersion?: string;
  cvss?: number;
  references?: string[];
}

export async function scanVulnerabilities(params: VulnerabilityScanParams): Promise<ScanResult> {
  const { scanType, target, severity = 'all' } = params;
  const startTime = Date.now();

  try {
    let result: ScanResult;

    switch (scanType) {
      case 'container':
        result = await scanContainer(target, severity);
        break;
      case 'dependency':
        result = await scanDependencies(target, severity);
        break;
      case 'network':
        result = await scanNetwork(target, severity);
        break;
      case 'web':
        result = await scanWebApplication(target, severity);
        break;
      default:
        throw new Error(`Unknown scan type: ${scanType}`);
    }

    result.scanDuration = Date.now() - startTime;
    return result;
  } catch (error) {
    return {
      type: scanType,
      target,
      collectedAt: new Date().toISOString(),
      vulnerabilities: [],
      summary: { critical: 0, high: 0, medium: 0, low: 0, total: 0 },
      scanDuration: Date.now() - startTime,
    };
  }
}

async function scanContainer(image: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    // Try to use Trivy for container scanning
    const { stdout } = await execAsync(
      `trivy image --format json --severity ${severity === 'all' ? 'CRITICAL,HIGH,MEDIUM,LOW' : severity.toUpperCase()} ${image}`,
      { maxBuffer: 50 * 1024 * 1024 } // 50MB buffer for large scan results
    );

    const scanResults = JSON.parse(stdout);
    
    for (const result of scanResults.Results || []) {
      for (const vuln of result.Vulnerabilities || []) {
        vulnerabilities.push({
          id: vuln.VulnerabilityID,
          severity: vuln.Severity.toLowerCase(),
          title: vuln.Title || vuln.VulnerabilityID,
          description: vuln.Description,
          package: `${result.Target}/${vuln.PkgName}`,
          version: vuln.InstalledVersion,
          fixedVersion: vuln.FixedVersion,
          cvss: vuln.CVSS?.nvd?.V3Score,
          references: vuln.References,
        });
      }
    }
  } catch {
    // Trivy not available, return mock data for demonstration
    vulnerabilities.push({
      id: 'CVE-MOCK-0001',
      severity: 'high',
      title: 'Mock Vulnerability - Trivy not installed',
      description: 'Install Trivy for actual container scanning: https://aquasecurity.github.io/trivy/',
      package: image,
    });
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'container',
    target: image,
    collectedAt: new Date().toISOString(),
    vulnerabilities,
    summary,
    scanDuration: 0,
  };
}

async function scanDependencies(projectPath: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];

  try {
    // Try npm audit for Node.js projects
    const { stdout } = await execAsync(
      `cd "${projectPath}" && npm audit --json`,
      { maxBuffer: 10 * 1024 * 1024 }
    );

    const auditResults = JSON.parse(stdout);
    
    for (const [, advisory] of Object.entries(auditResults.advisories || {})) {
      const adv = advisory as Record<string, unknown>;
      const advSeverity = (adv.severity as string).toLowerCase();
      
      if (severity !== 'all' && advSeverity !== severity) continue;

      vulnerabilities.push({
        id: `GHSA-${adv.id}`,
        severity: advSeverity,
        title: adv.title as string,
        description: adv.overview as string,
        package: adv.module_name as string,
        version: (adv.findings as Array<{ version: string }>)?.[0]?.version,
        fixedVersion: adv.patched_versions as string,
        references: [adv.url as string],
      });
    }
  } catch {
    // npm audit not available or failed, try other package managers or return mock
    try {
      // Try pip-audit for Python projects
      const { stdout } = await execAsync(
        `cd "${projectPath}" && pip-audit --format=json`,
        { maxBuffer: 10 * 1024 * 1024 }
      );

      const auditResults = JSON.parse(stdout);
      for (const vuln of auditResults) {
        vulnerabilities.push({
          id: vuln.id,
          severity: vuln.fix_versions?.length ? 'medium' : 'high',
          title: `${vuln.name} vulnerability`,
          description: vuln.description,
          package: vuln.name,
          version: vuln.version,
          fixedVersion: vuln.fix_versions?.join(', '),
        });
      }
    } catch {
      vulnerabilities.push({
        id: 'MOCK-DEP-0001',
        severity: 'medium',
        title: 'Mock Dependency Vulnerability',
        description: 'Install npm or pip-audit for actual dependency scanning',
        package: projectPath,
      });
    }
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'dependency',
    target: projectPath,
    collectedAt: new Date().toISOString(),
    vulnerabilities,
    summary,
    scanDuration: 0,
  };
}

async function scanNetwork(target: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];

  try {
    // Try to use nmap for network scanning
    const { stdout } = await execAsync(
      `nmap -sV -sC --script vuln ${target} -oX -`,
      { maxBuffer: 10 * 1024 * 1024, timeout: 300000 } // 5 minute timeout
    );

    // Parse nmap XML output (simplified)
    // In a real implementation, use an XML parser
    if (stdout.includes('VULNERABLE')) {
      const vulnMatches = stdout.match(/CVE-\d{4}-\d+/g) || [];
      for (const cve of [...new Set(vulnMatches)]) {
        vulnerabilities.push({
          id: cve,
          severity: 'high',
          title: `Network vulnerability: ${cve}`,
          description: 'Detected by nmap vulnerability scan',
          package: target,
        });
      }
    }
  } catch {
    // nmap not available, return mock data
    vulnerabilities.push({
      id: 'MOCK-NET-0001',
      severity: 'info',
      title: 'Mock Network Scan Result',
      description: 'Install nmap for actual network vulnerability scanning',
      package: target,
    });
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'network',
    target,
    collectedAt: new Date().toISOString(),
    vulnerabilities: filterBySeverity(vulnerabilities, severity),
    summary,
    scanDuration: 0,
  };
}

async function scanWebApplication(url: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];

  try {
    // Basic security header checks
    const response = await axios.get(url, {
      timeout: 30000,
      validateStatus: () => true,
    });

    const headers = response.headers;

    // Check for security headers
    const securityHeaders = {
      'strict-transport-security': {
        present: !!headers['strict-transport-security'],
        severity: 'high',
        title: 'Missing HSTS Header',
      },
      'content-security-policy': {
        present: !!headers['content-security-policy'],
        severity: 'medium',
        title: 'Missing Content Security Policy',
      },
      'x-frame-options': {
        present: !!headers['x-frame-options'],
        severity: 'medium',
        title: 'Missing X-Frame-Options Header',
      },
      'x-content-type-options': {
        present: !!headers['x-content-type-options'],
        severity: 'low',
        title: 'Missing X-Content-Type-Options Header',
      },
      'x-xss-protection': {
        present: !!headers['x-xss-protection'],
        severity: 'low',
        title: 'Missing X-XSS-Protection Header',
      },
      'referrer-policy': {
        present: !!headers['referrer-policy'],
        severity: 'low',
        title: 'Missing Referrer-Policy Header',
      },
    };

    for (const [header, config] of Object.entries(securityHeaders)) {
      if (!config.present) {
        vulnerabilities.push({
          id: `WEB-${header.toUpperCase().replace(/-/g, '_')}`,
          severity: config.severity,
          title: config.title,
          description: `The ${header} security header is not set`,
          package: url,
          references: [`https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/${header}`],
        });
      }
    }

    // Check for information disclosure
    if (headers['server']) {
      vulnerabilities.push({
        id: 'WEB-SERVER-DISCLOSURE',
        severity: 'low',
        title: 'Server Version Disclosure',
        description: `Server header reveals: ${headers['server']}`,
        package: url,
      });
    }

    if (headers['x-powered-by']) {
      vulnerabilities.push({
        id: 'WEB-POWERED-BY-DISCLOSURE',
        severity: 'low',
        title: 'Technology Stack Disclosure',
        description: `X-Powered-By header reveals: ${headers['x-powered-by']}`,
        package: url,
      });
    }

    // Check TLS (if HTTPS)
    if (url.startsWith('https://')) {
      // In a real implementation, you would check certificate validity, cipher suites, etc.
      vulnerabilities.push({
        id: 'WEB-TLS-CHECK',
        severity: 'info',
        title: 'TLS Configuration',
        description: 'HTTPS is enabled. For detailed TLS analysis, use tools like testssl.sh',
        package: url,
      });
    } else {
      vulnerabilities.push({
        id: 'WEB-NO-HTTPS',
        severity: 'critical',
        title: 'No HTTPS',
        description: 'The application is not using HTTPS encryption',
        package: url,
      });
    }
  } catch (error) {
    vulnerabilities.push({
      id: 'WEB-SCAN-ERROR',
      severity: 'info',
      title: 'Web Scan Error',
      description: error instanceof Error ? error.message : 'Failed to scan web application',
      package: url,
    });
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'web',
    target: url,
    collectedAt: new Date().toISOString(),
    vulnerabilities: filterBySeverity(vulnerabilities, severity),
    summary,
    scanDuration: 0,
  };
}

function calculateSummary(vulnerabilities: Vulnerability[]): {
  critical: number;
  high: number;
  medium: number;
  low: number;
  total: number;
} {
  return {
    critical: vulnerabilities.filter((v) => v.severity === 'critical').length,
    high: vulnerabilities.filter((v) => v.severity === 'high').length,
    medium: vulnerabilities.filter((v) => v.severity === 'medium').length,
    low: vulnerabilities.filter((v) => v.severity === 'low' || v.severity === 'info').length,
    total: vulnerabilities.length,
  };
}

function filterBySeverity(
  vulnerabilities: Vulnerability[],
  severity: string
): Vulnerability[] {
  if (severity === 'all') return vulnerabilities;

  const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
  const minSeverityIndex = severityOrder.indexOf(severity);

  return vulnerabilities.filter((v) => {
    const vulnSeverityIndex = severityOrder.indexOf(v.severity);
    return vulnSeverityIndex <= minSeverityIndex;
  });
}




